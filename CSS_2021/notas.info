* Sintaxis
==================

* Selector: El elemento al que vamos a aplicar estilos
* Propiedad: Lo que vamos a cambiar
* Valor:  El nuevo valor que le vamos a dar a la propiedad
* Propiedad: Valor -> Se le denomina declaración
* Al conjunto de selector + declaracion(es) se le denomina regla


* Selectores
==================

- Selectores simples

    - Elementales

        - Selector universal -> *
        - Selector de tipo o de etiqueta 
    
    - De atributo
        
        - id -> id del elemento
        - clase -> clase del elemento
        - otros atributos -> 
            [atributo]
            [atributo=valor]
            [atributo^=valor] <- comprobar si el atributo empieza por ese valor
            [atributo*=valor] <- se selecciona el valor que coincida independiente de su posicion
            [atributo$=valor] <- comprobar si el atributo termina por ese valor
            [atributo|=valor] <- incluye el valor y valor-...

- Selectores compuestos

    - Agrupados <- atributos separados por ','
    - Combinadores 
        Selector descendiente <- un selector dentro de otro -> [atributo] [atributo]
        Selector de hermano siguiente <- permite seleccionar el elemento hermano siguiente -> [atributo] + [atributo]
        Selector de todos los hermanos siguientes <- permite seleccionar todos los elementos hermanos siguientes -> [atributo] ~ // el simbolo es ALTGR + 4
        Selector de hijo directo <- permite seleccionar sólo los hijos directos -> [atributo] > [atributo]
    - Pseudoclases - pseudoelementos (más adelante)


* Cómo funciona css
=========================

- Especificidad -> Establece cómo de específico es un selector para saber qué estilo aplicar.
                    El cálculo se realiza con la siguiente fórmula:

                     Etiquetas y pseudoelementos -> 001
                     Clases, atributos, pseduoclases -> 010
                     Ids -> 100
                     Estilos en línea -> 1000
                     !important -> GANA A TODO pero se carga la especificidad <- NO USAR NUNCA -- UTILIZAR SIEMPRE CLASES!

            Cascada -> funciona siempre que la especificidad sobre el elemento sea la misma
            Herencia  -> Es la capacidad que tienen algunos elementos de heredar algunas propiedades de sus elementos 
                         contenedores (padres, abuelos, etc)
                         Para forzar la herencia en los elementos que no la tienen por defecto usamos -> inherit
                         Para evitar que un elemento herede una propiedad por defecto usamos -> inital

- como saber si se escribe buen css -> https://jonassebastianohlsson.com/specificity-graph/


* Normalizar estilos de los navegadores
==========================================

https://necolas.github.io/normalize.css/

* Prefijos propietarios
==========================================

- ayuda a poner los prefijos automaticamente -> https://autoprefixer.github.io/
- programa que pone automaticamente los prefijos -> https://prepros.io/

* Box model
==============================

- las cajas se componen principalmente de:
 
        * contenido
        * borde
        * padding
        * margin
        * width
        * height

    # Alto & Ancho

        - Width -> Ancho
        - Height -> Alto

        - Para los elementos en bloque establecen el ancho y el alto
        - Los elementos en línea no tienen medidas, el tamaño lo determina su contenido

    # Margin

        - Es la propiedad que nos permite generar espacio entre elementos.
        - Es un shorthand que controla los cuatro lados posibles a los que dar márquenes.
        - margin-top: Margen superior
        - margin-right: Margen derecho
        - margin-bottom: Margen inferior
        - margin-left: Margen derecho
        - Admite hasta cuatro valores que van en el orden de las agujas del reloj:
            4 valores -> top right bottom left
            3 valores -> top left/right bottom
            2 valores -> top/bottom left/right
            1 valor -> top/right/bottom/left

        - En los elementos en línea los margin top/bottom (verticales) no funcionan
        - En los elementos en línea los margin left/right (horizontales) si funcionan

        - Para los elementos en bloque: (IMPORTANTE: debe ser de bloque y se debe haber establecido el ancho (width))

            margin-right: auto; <- pegamos el elemento a la izquierda
            margin-left: auto; <- pegamos el elemento a la derecha

            si declaremos las dos a auto al mismo tiempo centramos el elemento

        - Malas prácticas:

            * { margin: 0; padding: 0}
            para centrar un elemento no ulizar: margin: 0 auto / usar -> margin-left: auto; margin-right: auto;
            se recomienda body { margin: 0} <- el padding: 0 no es util ya que no por defecto no tiene padding


    # Padding

        - Es la propiedad que nos permite generar espacio entre interno entre el bordy y la caja
        - Es un shorthand que controla los 4 lados posibles 
        - margin-top: padding superior
        - margin-right: padding derecho
        - margin-bottom: padding inferior
        - margin-left: padding derecho
        - Admite hasta cuatro valores que van en el orden de las agujas del reloj:
            4 valores -> top right bottom left
            3 valores -> top left/right bottom
            2 valores -> top/bottom left/right
            1 valor -> top/right/bottom/left

        - Funciona igual para elementos en bloque y en línea
        - Si el objetivo es separar la caja de los elementos que la rodean -> margin
        - Si el objetivo es automentar el temaño de la caja y separar los bordes del contenido -> padding
        
    # Border

        - Es la propiedad que nos permite modificar el borde de la caja
        - Es un shorthand que agrupa tres propiedades
        - border-width: ancho del borde <- shorthand (border-top-width...)
        - border-style: estilo del borde <- shorthand (border-top-style...)
        - border-color: color del borde <- shorthand (border-top-color...)

        * Border-radius

            - Es la propiedad que nos permite redondear vertices de forma independiente
            - Es un shorthand que engloba cuatro propiedades (border-top-left-radius, border-top-right-radius...)
            - Si sólo recibe un valor dibjará un círculo en cada vértice del radio que especifiquemos
            - Si utilizamos el border-radius como shorthand hay diferencias entre si queremos dar un valor a cada lado (círculo) o dos (elipse)

        
    # Box-sizing

        - Es la propiedad que nos permite controlar el cálculo que hace el navegador a la hora de modificar las popiedades content, padding y border.
        - Los dos valores que podemos dar son:
            content-box -> Valor por defecto
            border-box -> cálculo de tamaño del elemento incluyendo el padding y el border

        - buena practica:
            *{ box-sizing: border-box}


* Overflow
==============================

- Decimos que un contenido se desborda cuando la caja es más pequeña que el contenedor
- Es la propiedad que controla qué debe haer la caja cuando su contenido se desborda del contenedor
- Es un shorthand de overflow-x y overflow-y
- Tiene cuatro valores posibles:
    visible -> es el valor por defecto
    hidden -> El contenido que se desborde no se verá. Si aplicamos este propiedad en un solo eje, el otro se pondrá automaticamente en el valor scroll.
    scroll -> aparecerán barras de scroll en el eje asignado
    auto -> aparecerán barras de scroll en el caso de que hicieran falta
    
* Colapsado de márgenes
==============================

- problema: si tenemos una caja con un margin-bottom de 20 pixeles y debajo de ella otra con un margin-top de otros 20px, la lógica es que la separación entre
            ellas fuera de 40 px, pero en realidad se queda en 20px, ya que los márgenes verticales colapsan (se solpan)
- lo que se recomienda es dar margin bottom a los elementos e ir bajando el resto de elementos, ir empujando los elementos hacia abajo con margin-bottom.
- en los horizontales no pasa

- otro problema es el colapsado de márgenes entre padres e hijos, en el ejemplo al meter el h1 en el header, el header se separa del top de la página
- en el ejemplo lo solucionamos con tres trucos diferentes:
    1. darle al contenedor un overflow: hidden;
    2. añadir un padding-top al padre de cualquier tamaño (por ejemplo: 0.1 px)
    3. añadir border-top aunque sea de 0.1px

* Display
============================

- sirve para cambiar el contexto de los elemento sdentro del navegador
- Admite varios valores
    none -> hace que el elemento no se muestre, pero sigue cargandose
    block -> Hace que el elemento sea de bloque
    inline -> Hace que el elemento sea de línea
    inline-block -> Hace que el elemento sea de línea pero admite medidas y márgenes verticales

* Outline
============================

- es la propiedad  que nos permite dibujar un borde por fuera del model de caja
- es un shorthand que engloba (outline-width..style..color)
- tiene las mismas propiedades y sintaxis que border, pero con algunas diferencias
    No ocupa sitio, ya que no forma parte del box-model
    No se puede redondear
    No se pueden controlar los lados de forma independiente
- tambien cuenta con la propiedad outline-offset, que nos permite aumenta o disminuir la distancia del outline en relacion a la caja a la que pertenece

* Text align
============================

- es la propiedad que nos permite alinear horizontalmente el contenido de un elemento de bloque siempre que el contenido NO TENGA ANCHO DECLARADO
- acepta cuatro posibles valores
    text-align: left;
    text-align: right;
    text-align: center;
    text-align: jusrify; <- No es recomendable
- las imagenes por defecto son display: inline-block, para centrar una imagen hay que poner display: block

* Box shadow
============================

- se creo para añadir efectos de sombra a la caja
- en esencia lo que hace es crear un clon de la caja respetando la forma de su box-model
- la sintaxis se puede escribir de distintas formas según lo que queramos conseguir
- los valores posibles
    offset-x -> desplazamiento en x (obligatorio)
    offset-y -> desplazamiento en y (obligatorio)
    blur-radius -> desenfoque de la sombra
    spread-radius -> expansión de la sombra
    color -> color de la sombra, si no se especifica lo heredará  del elemento al que pertenece
    inset -> determina si la sombra será interior o exterior
- box shadow no ocupa sitio en el modelo (box model)
- https://www.codesdope.com/blog/article/10-amazing-effects-you-can-create-using-box-shadow/


