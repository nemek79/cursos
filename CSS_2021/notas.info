* Sintaxis
==================

* Selector: El elemento al que vamos a aplicar estilos
* Propiedad: Lo que vamos a cambiar
* Valor:  El nuevo valor que le vamos a dar a la propiedad
* Propiedad: Valor -> Se le denomina declaración
* Al conjunto de selector + declaracion(es) se le denomina regla


* Selectores
==================

- Selectores simples

    - Elementales

        - Selector universal -> *
        - Selector de tipo o de etiqueta 
    
    - De atributo
        
        - id -> id del elemento
        - clase -> clase del elemento
        - otros atributos -> 
            [atributo]
            [atributo=valor]
            [atributo^=valor] <- comprobar si el atributo empieza por ese valor
            [atributo*=valor] <- se selecciona el valor que coincida independiente de su posicion
            [atributo$=valor] <- comprobar si el atributo termina por ese valor
            [atributo|=valor] <- incluye el valor y valor-...

- Selectores compuestos

    - Agrupados <- atributos separados por ','
    - Combinadores 
        Selector descendiente <- un selector dentro de otro -> [atributo] [atributo]
        Selector de hermano siguiente <- permite seleccionar el elemento hermano siguiente -> [atributo] + [atributo]
        Selector de todos los hermanos siguientes <- permite seleccionar todos los elementos hermanos siguientes -> [atributo] ~ // el simbolo es ALTGR + 4
        Selector de hijo directo <- permite seleccionar sólo los hijos directos -> [atributo] > [atributo]
    - Pseudoclases - pseudoelementos (más adelante)


* Cómo funciona css
=========================

- Especificidad -> Establece cómo de específico es un selector para saber qué estilo aplicar.
                    El cálculo se realiza con la siguiente fórmula:

                     Etiquetas y pseudoelementos -> 001
                     Clases, atributos, pseduoclases -> 010
                     Ids -> 100
                     Estilos en línea -> 1000
                     !important -> GANA A TODO pero se carga la especificidad <- NO USAR NUNCA -- UTILIZAR SIEMPRE CLASES!

            Cascada -> funciona siempre que la especificidad sobre el elemento sea la misma
            Herencia  -> Es la capacidad que tienen algunos elementos de heredar algunas propiedades de sus elementos 
                         contenedores (padres, abuelos, etc)
                         Para forzar la herencia en los elementos que no la tienen por defecto usamos -> inherit
                         Para evitar que un elemento herede una propiedad por defecto usamos -> inital

- como saber si se escribe buen css -> https://jonassebastianohlsson.com/specificity-graph/


* Normalizar estilos de los navegadores
==========================================

https://necolas.github.io/normalize.css/

* Prefijos propietarios
==========================================

- ayuda a poner los prefijos automaticamente -> https://autoprefixer.github.io/
- programa que pone automaticamente los prefijos -> https://prepros.io/

* Box model
==============================

- las cajas se componen principalmente de:
 
        * contenido
        * borde
        * padding
        * margin
        * width
        * height

    # Alto & Ancho

        - Width -> Ancho
        - Height -> Alto

        - Para los elementos en bloque establecen el ancho y el alto
        - Los elementos en línea no tienen medidas, el tamaño lo determina su contenido

    # Margin

        - Es la propiedad que nos permite generar espacio entre elementos.
        - Es un shorthand que controla los cuatro lados posibles a los que dar márquenes.
        - margin-top: Margen superior
        - margin-right: Margen derecho
        - margin-bottom: Margen inferior
        - margin-left: Margen derecho
        - Admite hasta cuatro valores que van en el orden de las agujas del reloj:
            4 valores -> top right bottom left
            3 valores -> top left/right bottom
            2 valores -> top/bottom left/right
            1 valor -> top/right/bottom/left

        - En los elementos en línea los margin top/bottom (verticales) no funcionan
        - En los elementos en línea los margin left/right (horizontales) si funcionan

        - Para los elementos en bloque: (IMPORTANTE: debe ser de bloque y se debe haber establecido el ancho (width))

            margin-right: auto; <- pegamos el elemento a la izquierda
            margin-left: auto; <- pegamos el elemento a la derecha

            si declaremos las dos a auto al mismo tiempo centramos el elemento

        - Malas prácticas:

            * { margin: 0; padding: 0}
            para centrar un elemento no ulizar: margin: 0 auto / usar -> margin-left: auto; margin-right: auto;
            se recomienda body { margin: 0} <- el padding: 0 no es util ya que no por defecto no tiene padding


    # Padding

        - Es la propiedad que nos permite generar espacio entre interno entre el bordy y la caja
        - Es un shorthand que controla los 4 lados posibles 
        - margin-top: padding superior
        - margin-right: padding derecho
        - margin-bottom: padding inferior
        - margin-left: padding derecho
        - Admite hasta cuatro valores que van en el orden de las agujas del reloj:
            4 valores -> top right bottom left
            3 valores -> top left/right bottom
            2 valores -> top/bottom left/right
            1 valor -> top/right/bottom/left

        - Funciona igual para elementos en bloque y en línea
        - Si el objetivo es separar la caja de los elementos que la rodean -> margin
        - Si el objetivo es automentar el temaño de la caja y separar los bordes del contenido -> padding
        
    # Border

        - Es la propiedad que nos permite modificar el borde de la caja
        - Es un shorthand que agrupa tres propiedades
        - border-width: ancho del borde <- shorthand (border-top-width...)
        - border-style: estilo del borde <- shorthand (border-top-style...)
        - border-color: color del borde <- shorthand (border-top-color...)

        * Border-radius

            - Es la propiedad que nos permite redondear vertices de forma independiente
            - Es un shorthand que engloba cuatro propiedades (border-top-left-radius, border-top-right-radius...)
            - Si sólo recibe un valor dibjará un círculo en cada vértice del radio que especifiquemos
            - Si utilizamos el border-radius como shorthand hay diferencias entre si queremos dar un valor a cada lado (círculo) o dos (elipse)

        
    # Box-sizing

        - Es la propiedad que nos permite controlar el cálculo que hace el navegador a la hora de modificar las popiedades content, padding y border.
        - Los dos valores que podemos dar son:
            content-box -> Valor por defecto
            border-box -> cálculo de tamaño del elemento incluyendo el padding y el border

        - buena practica:
            *{ box-sizing: border-box}


* Overflow
==============================

- Decimos que un contenido se desborda cuando la caja es más pequeña que el contenedor
- Es la propiedad que controla qué debe haer la caja cuando su contenido se desborda del contenedor
- Es un shorthand de overflow-x y overflow-y
- Tiene cuatro valores posibles:
    visible -> es el valor por defecto
    hidden -> El contenido que se desborde no se verá. Si aplicamos este propiedad en un solo eje, el otro se pondrá automaticamente en el valor scroll.
    scroll -> aparecerán barras de scroll en el eje asignado
    auto -> aparecerán barras de scroll en el caso de que hicieran falta
    
* Colapsado de márgenes
==============================

- problema: si tenemos una caja con un margin-bottom de 20 pixeles y debajo de ella otra con un margin-top de otros 20px, la lógica es que la separación entre
            ellas fuera de 40 px, pero en realidad se queda en 20px, ya que los márgenes verticales colapsan (se solpan)
- lo que se recomienda es dar margin bottom a los elementos e ir bajando el resto de elementos, ir empujando los elementos hacia abajo con margin-bottom.
- en los horizontales no pasa

- otro problema es el colapsado de márgenes entre padres e hijos, en el ejemplo al meter el h1 en el header, el header se separa del top de la página
- en el ejemplo lo solucionamos con tres trucos diferentes:
    1. darle al contenedor un overflow: hidden;
    2. añadir un padding-top al padre de cualquier tamaño (por ejemplo: 0.1 px)
    3. añadir border-top aunque sea de 0.1px

* Display
============================

- sirve para cambiar el contexto de los elemento sdentro del navegador
- Admite varios valores
    none -> hace que el elemento no se muestre, pero sigue cargandose
    block -> Hace que el elemento sea de bloque
    inline -> Hace que el elemento sea de línea
    inline-block -> Hace que el elemento sea de línea pero admite medidas y márgenes verticales

* Outline
============================

- es la propiedad  que nos permite dibujar un borde por fuera del model de caja
- es un shorthand que engloba (outline-width..style..color)
- tiene las mismas propiedades y sintaxis que border, pero con algunas diferencias
    No ocupa sitio, ya que no forma parte del box-model
    No se puede redondear
    No se pueden controlar los lados de forma independiente
- tambien cuenta con la propiedad outline-offset, que nos permite aumenta o disminuir la distancia del outline en relacion a la caja a la que pertenece

* Text align
============================

- es la propiedad que nos permite alinear horizontalmente el contenido de un elemento de bloque siempre que el contenido NO TENGA ANCHO DECLARADO
- acepta cuatro posibles valores
    text-align: left;
    text-align: right;
    text-align: center;
    text-align: jusrify; <- No es recomendable
- las imagenes por defecto son display: inline-block, para centrar una imagen hay que poner display: block

* Box shadow
============================

- se creo para añadir efectos de sombra a la caja
- en esencia lo que hace es crear un clon de la caja respetando la forma de su box-model
- la sintaxis se puede escribir de distintas formas según lo que queramos conseguir
- los valores posibles
    offset-x -> desplazamiento en x (obligatorio)
    offset-y -> desplazamiento en y (obligatorio)
    blur-radius -> desenfoque de la sombra
    spread-radius -> expansión de la sombra
    color -> color de la sombra, si no se especifica lo heredará  del elemento al que pertenece
    inset -> determina si la sombra será interior o exterior
- box shadow no ocupa sitio en el modelo (box model)
- https://www.codesdope.com/blog/article/10-amazing-effects-you-can-create-using-box-shadow/


* Position
============================

- nos permite posicionar los elementos.
- Flujo de renderizado -> Por normal general los elementos se dibujan de izquierda a derecha y de arriba a abajo. El punto 0,0 de los elementos, por norma general,
                            es la esquina superior izquierda.
- Espacio reservado -> Es el espacio que tiene un elemento asignado en el navegador.
- Elemento posicionado -> Significa que el elemento tiene la propiedad position con un valor distinto de "static", que es el valor que tiene esta propiedad por defecto.
- Stackin context -> contexto de apilamiento. es el orden en el que se aplilarán las cajas que se superponen.
                     es el espacio donde nuestros elementos se van a ir apilando para que unos queden por detrás y otros por delante
                     el orden es:
                        elementos posicionados con un z-index de 1 o más
                        elementos posicionados sin z-index o auto
                        elementos no posicionados
                        elementos con z-index negativo
                    puede haber diferentes contextos de apilamiento dependiendo de las propiedades que se le dan a los elementos
- Al posicionar un elemento se habilitan cinco propiedades que podemos utlizar para mover los elementos en los tres ejes
    top -> el elemento se moverá desde la parte superior en la distancia que hayamos indicado
    right -> El elemento se moverá desde la parte derecha la distancia que hayamos indicado
    bottom -> ...
    left -> ...
    z-index -> nos permite mover el elemento en el contexto de apilamiento (eje-z) (z-index: auto; es lo mismo que no poner nada)
                intentar no utilizar números consecutivos (por si crece la aplicación)
                ! hijo contenido en padre y queremos poner el padre por delante del hijo -> hay que poner el hijo por detrás del padre: hijo con z-index: -1 y el padre sin z-index
    NOTA: si a un elemento le declaramos la propiedad top y/o left, las propiedades bottom y/o right no funcionarán
- Los posibles valores que podemos dar son:
    static -> por defecto, con este valor el elemento NO ESTÁ POSICIONADO y por tanto no podremos moverlo
    relative -> el elemento mantiene su posición y medidas en el flujo de renderizado y mantendrá su espacio reservado. Si lo movemos lo hará usando su posición en el 
                html como punto de referencia
                podemos obligar a los elementos a ocupar un mismo espacio
    absolute -> el elemento perderá sus medidas y su espacio reservado. Si lo movemos usará el elemento padre posicionado como referencia. si no tiene ninguno, usará el
                elemento html de referencia
                lo importante es que el contenedor está posicionado (da igual el tipo) y no hace falta que el elemento sea hijo directo del contenedor
                cuando se le da absolute a un elemento en linea se genera un contexto de bloque automaticamente y poder darle medidas (ya se le puede dar medidas, margenes...)
    fixed -> el elemento perderá sus medidas y su espacio reservado. si lo movemos usará el elemento html de referencia y además se quedará fijo en esa posición, aunque
            hagamos scroll
    sticky -> es una meza de relative y fixed. los valores top, left, bottom y right no sriven para mover el elemento, sirven para indicarle en qué punto pasará a tener un 
                comportamiento de posicionamiento fixed, hasta llegar a ese punto se comportará como si tuviera relative.


* Ordenación de propiedades
============================

- es importante, no existe ninguna norma ni especificacion sobre cómo hacerlo, pero la mayoría de los expertos coinciden en los mismo puntos:

    1. Propiedades de posicionamiento
    2. Propiedades del box-model
    3. Propiedades de texto
    4. Propiedades visuales (colores, bordes, background...)
    5. Resto de propiedades

* Medidas
============================

- se pueden agrupar en absolutas y relativas
- absolutas
    NO CAMBIAN y siempre mantendrán su tamaño, independientemente del dispositivo o la interacción con el usuario
    La más usada es px cuya mediad es 1/96 de 1in, pero existen otras como: cm, mm,Q, in, pc, pt
- relativas
    SIEMPRE dependen de un contexto, son las que se recomienda utilizar en la gran mayoría de ocasiones porque nos van a permitir que todos los 
    elementos escalen proporcionalmente
    las más usadas son em, rem, %, vw, vh, vmin y vmax, pero existen otras como: ex, ch, lh

- rem -> Corresponde a la medida de la "m" de la raiz del documento (html)
- em -> Corresponde a la medida de la "m" del contexto donde nos encontremos.

- El estándar del tamaño de fuente por defecto en la raiz del documento es 16px, y NO ES RECOMENDABE MODIFICARLO.

- NOTA: Tanto em como rem se calcula en base a la propiedad font-size (tamaño de fuente)

- ejemplo: 1rem = 16px

- Recomendaciones:

 Para tamños de fuentes usar SIEMPRE rem, porque asi no habra problemas con el contexto en el que nos encontremos

 Por ejemplo, para dejar espacio al texto de un boton el padding va en em, igual que el border mientras que la fuente va en rem
 
  


    
